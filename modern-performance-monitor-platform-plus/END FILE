This is a highly simplified example. A full-scale system would require:

* **Expanded Model:**  Include more metrics (disk I/O, network, etc.), timestamps, and potentially application-specific performance indicators.
* **Robust Service Layer:** Implement data processing, calculations (e.g., averages, trends), and potentially alerts.
* **Database:**  Choose a production-ready database (PostgreSQL, MySQL) instead of H2 for scalability and reliability.  Implement proper schema design, migrations, and potentially indexing for optimized query performance.
* **Frontend:**  Build a user interface (React, Angular, Vue.js) to visualize the metrics in dashboards.
* **Authentication and Authorization:** Implement secure authentication (e.g., using Spring Security) and role-based access control.
* **Comprehensive Testing:**  Write unit, integration, and end-to-end tests to ensure quality and stability.
* **CI/CD:** Set up a continuous integration and continuous deployment pipeline (e.g., using Jenkins, GitLab CI, or GitHub Actions) for automated builds and deployments.
* **Monitoring and Logging:** Integrate with monitoring tools (e.g., Prometheus, Grafana) and logging frameworks (e.g., Log4j, SLF4j) for observability.
* **Error Handling:** Implement robust error handling and exception management throughout the application.
* **Caching:** Use a caching layer (e.g., Redis) to improve performance.
* **Rate Limiting:** Implement rate limiting to prevent abuse of the API.


Remember to replace placeholders with actual implementations and add the missing components to create a complete system.  This response provides only a very basic starting point.  Building a production-ready system is a complex undertaking requiring significant development effort.